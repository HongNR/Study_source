다대일 양방향
- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

일대다 단방향
- 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
- 테이블 일대다 관계는 항상 다(N)쪽에 외래키가 있음
- 객체와 테이블의 차이때문에 반대편 테이블의 외래키를 관리하는 특이한 구조
- @JoinColumn을 꼭 사용해야함.
일대다 단방향매핑의 단점
- 엔티티가 관리하는 외래키가 다른 테이블에 있음
===> 일대다 단방향 매핑보다는 **다대일 양방향매핑**을 사용하자

일대일 관계
- 일대일 관계는 그 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
    - 주 테이블에 외래 키 or 대상 테이블에 외래 키
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

일대일: 대상 테이블에 외래 키 단방향
- 단방향 관계는 JPA 지원x

다대다 관계
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
- 편리해보이지만 실무에서는 사용 X
- 연결 테이블이 단순히 연결만 하고 끝나지 않음
- 주문시간, 수량 같은 데이터가 들어올 수 있음


<상속관계 매핑>
- 관계형 데이터베이스는 상속관계 X
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입관계를 매핑
@Inheritance(strategy = InheritanceType.XXX)
    - JOINED : 조인전략
    - SINGLE_TABLE : 단일 테이블 전략
    - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 (***쓰면 안되는 전략!!!)
@DiscriminatorColumn : DTYPE이 추가됨

* 조인전략(JOINED)
- 장점
    - 테이블 정규화
    - 외래키 참조 무결성 제약조건 활용가능
    - 저장공간 효울화
- 단점
    - 조회시 조인을 많이 사용, 성능 저하
    - 조회 쿼리가 복잡함
    - 데이터 저장시 INSERT SQL 2번 호출

* 단일 테이블 전략(SINGLE_TABLE)
- 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
- 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다.
      상황에 따라서 조회 성능이 오히려 느려질 수 있다.


@MappedSuperclass
- 상속관계 매핑X
- 엔티티X, 테이블과 매핑X
- 부모 클래스를 상속받는 자식클래스에 매핑 정보만 제공
- 조회, 검색불가
- 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장

- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑정보를 모으는 역할
- 주로 등록일, 수정일, 등록자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
- 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능

<프록시>
- em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회
- em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회

• 프록시 인스턴스의 초기화 여부 확인
PersistenceUnitUtil.isLoaded(Object entity)
• 프록시 클래스 확인 방법
entity.getClass().getName() 출력(..javasist.. or HibernateProxy…)
• 프록시 강제 초기화
org.hibernate.Hibernate.initialize(entity);
• 참고: JPA 표준은 강제 초기화 없음
강제 호출: member.getName()

------ 즉시 로딩과 지연 로딩 ------
(fetch = FetchType.LAZY) : 지연 로딩
(fetch = FetchType.EAGER) : 즉시 로딩

프록시와 즉시로딩 주의
• 가급적 지연 로딩만 사용(특히 실무에서)
• 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
• 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.
• @ManyToOne, @OneToOne은 기본이 즉시 로딩
 -> LAZY로 설정
• @OneToMany, @ManyToMany는 기본이 지연 로딩


값 타입 분류
• 기본값 타입
    • 자바 기본 타입(int, double)
    • 래퍼 클래스(Integer, Long)
    • String

• 임베디드 타입(embedded type, 복합 값 타입)
    • 새로운 값 타입을 직접 정의할 수 있음
    • JPA는 임베디드 타입(embedded type)이라 함
    • 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
    • int, String과 같은 값 타입
임베디드 타입 사용법
    • @Embeddable: 값 타입을 정의하는 곳에 표시
    • @Embedded: 값 타입을 사용하는 곳에 표시
    • 기본 생성자 필수

• 컬렉션 값 타입(collection value type)
    • 값 타입을 하나 이상 저장할 때 사용
    • @ElementCollection, @CollectionTable 사용
    • 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.
    • 컬렉션을 저장하기 위한 별도의 테이블이 필요함


<JPQL>
    JPA를 사용하면 엔티티 객체를 중심으로 개발
    검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
    모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
    애플리케이션이 필요한 데이터만 DB에서 불러오려면
    결국 검색 조건이 포함된 SQL이 필요
• JPQL은 엔티티 객체를 대상으로 쿼리
• SQL은 데이터베이스 테이블을 대상으로 쿼리
• JPQL을 한마디로 정의하면 객체 지향 SQL


<QueryDSL 소개>
• 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
• JPQL 빌더 역할
• 컴파일 시점에 문법 오류를 찾을 수 있음
• 동적쿼리 작성 편리함
• 단순하고 쉬움
• 실무 사용 권장**

<경로 표현식 특징>
• 상태 필드(state field): 경로 탐색의 끝, 탐색X
• 단일 값 연관 경로: 묵시적 내부 조인(inner join) 발생, 탐색O
• 컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색X
    • FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능
• 가급적 묵시적 조인 대신에 명시적 조인 사용 **

<페치 조인과 일반 조인의 차이>
• 페치 조인을 사용할 때만 연관된 엔티티도 함께 조회(즉시 로딩)
• 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념
